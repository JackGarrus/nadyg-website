---
title: "Why Everyone Uses Docker, Even When They Don’t"
publishedAt: "2025-04-14"
summary: "How Docker open-sourced its runtime, yet became the standard, and found survival through developer tools"
image: "/public/docker-engine.png"
author: "Nadia Guarracino"
---

## The Docker Engine

<Image
  src="/docker-engine.png"
  alt="Docker Engine"
  sizes="100vw"
  style={{
    width: "100%",
    height: "auto",
  }}
  width={500}
  height={300}
/>

<br />
<br />
<br />

Under the hood, Docker is made up of <strong>two daemons</strong> (background processes
that interact with the system):

<ul>
  <li>
    <strong>dockerd</strong>: listens for Docker API requests and manages
    objects like images, containers, volumes, and networks.
  </li>
  <li>
    <strong>containerd</strong>: handles only the container lifecycle, with a
    lower-level interface.
  </li>
</ul>

Originally, containerd was just a component inside Docker, but as containers became more widely adopted, things got complicated, especially when Kubernetes entered the picture.

<br />
<br />
## Kubernetes Didn't Want Docker

Originally, Kubernetes only worked with Docker.
But over time, people wanted to use different runtimes (like containerd standalone, etc.).

<br />
So the Kubernetes team created <strong>CRI</strong>, so Kubernetes could support
any runtime, as long as it followed this standard interface.

<Callout>
  <strong>CRI</strong>:Container Runtime Interface. API that tells Kube how to
  talk to a container runtime
</Callout>

<br />

On top of that, <strong>dockerd</strong> was doing way more then Kube needed, like handling volumes, networks, image builds, and logs.
So the Kubernetes team decided to build something simpler: a lightweight runtime made just for Kubernetes, called <strong>CRI-O</strong>

<br />
<br />
<br />

## Docker’s Strategic Pivot

At that point, Docker Inc. realized something important:

“We're not going to make money from dockerd or containerd, but we can make money from developer tools.”

So in 2017, Docker made a bold move. It:

<ul>
  <li>
    open-sourced containerd
  </li>
  <li>
    donated it to the CNCF (Cloud Native Computing Foundation)
  </li>
  <li>
    pivoted to focus on Docker Desktop and Docker Hub
  </li>
</ul>

Smart play. Now the ecosystem could adopt containerd freely, and Docker could monetize elsewhere.

(And yes, Docker still uses containerd internally as part of dockerd. That didn't change.)

<br />
<br />
<br />

## Kubernetes surrenders to containerd

Once containerd became an open source standalone runtime, Kubernetes had to adopt it.

<br />
Why?
<br />

containerd became the most widely adopted container runtime in Kubernetes clusters, major cloud providers (AWS, GCP, Azure, IBM...) all adopted it.

<br />

CRI-O remained a valid alternative, but containerd won the popularity contest

<br />
And no — Kube didn’t “drop CRI.” It still uses it, but now it talks to containerd
directly using a CRI plugin, rather than going through dockerd

<br />
<br />
<br />

## Enter Colima

Meanwhile, most devs were still using Docker Desktop on macOS to run containers locally.

But then Docker Inc. started charging for Docker Desktop in certain cases, and developers looked for alternatives.

<br />

That’s when Colima entered the scene.

<br />
<br />
<br />

## What Is Colima?

Colima is a free, open-source replacement for Docker Desktop.

It doesn't replace the Docker engine itself, instead, it:

<ul>
  <li>
    provides a working dockerd + containerd environment
  </li>
  <li>
    runs inside a lightweight Linux VM (via Lima)
  </li>
  <li>
    works beautifully on macOS
  </li>
</ul>

Is CLI-based, fast, and ideal for devs who don’t need a GUI

<br />
So basically, Colima gives you a fully Docker-compatible setup, without Docker Desktop, without the licensing restrictions.

<br />
<Callout>
  <strong>Colima</strong> doesn’t replace the Docker engine: it replaces
  <strong>Docker Desktop</strong>.
</Callout>

<Image
  src="/colima-is.png"
  alt="colima is"
  sizes="100vw"
  style={{
    width: "100%",
    height: "auto",
  }}
  width={500}
  height={300}
/>

<br />
<br />
<br />

## Fun-fact: Docker Runs Natively on Linux

Of course it does.

Linux already has everything Docker needs built-in: cgroups, namespaces, container-friendly file systems...

<br />

Plus, <strong>Docker runs directly on the OS</strong>, that means that <strong>no VM required!</strong>

On the other hand though, on MacOS and Windows, a VM is necessary, therefore you need to install
Docker Desktop or Colima or something else.

<br />
<br />
<br />

## TL;DR

<ul>
  <li>
    <strong>containerd</strong> is now the <strong>industry standard</strong>{" "}
    container runtime.
  </li>
  <li>
    <strong>Docker Inc.</strong> makes money from{" "}
    <strong>Docker Desktop</strong>, not the daemons.
  </li>
  <li>
    <strong>Kubernetes</strong> adopted containerd because it was already
    widespread.
  </li>
  <li>
    <strong>Docker Hub</strong> is still the central container image registry.
  </li>
  <li>
    <strong>Colima</strong> is a free alternative to Docker Desktop on macOS.
  </li>
  <li>
    On <strong>Linux</strong>, Docker runs <strong>natively</strong> as no VM
    required.
  </li>
</ul>
<br />
<br />
<br />
<br />
